from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
import requests
import os
import json
import time
from datetime import datetime
from report_generator import generate_pdf_report, generate_excel_report

app = Flask(__name__)
CORS(app)

# Get Apify token from environment
APIFY_TOKEN = os.getenv('APIFY_API_TOKEN', '')

def haversine_distance(lat1, lon1, lat2, lon2):
    """Calculate distance between two points in miles"""
    from math import radians, sin, cos, sqrt, atan2
    
    R = 3959  # Earth's radius in miles
    
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1-a))
    
    return R * c

def fetch_property_and_comps(address):
    """Fetch subject property AND comps in ONE API call - faster and cheaper!"""
    
    if not APIFY_TOKEN:
        print("‚ö†Ô∏è  No Apify token - cannot fetch property details")
        return None
    
    print(f"üîç Fetching property + comps for: {address}")
    
    # STEP 1: Get subject property
    subject_input = {
        "addresses": address
    }
    
    try:
        # Get subject property
        response = requests.post(
            'https://api.apify.com/v2/acts/aknahin~zillow-property-info-scraper/runs',
            headers={'Authorization': f'Bearer {APIFY_TOKEN}'},
            json=subject_input,
            timeout=120
        )
        
        if response.status_code != 201:
            print(f"‚ùå Subject property fetch error: {response.status_code}")
            return None
        
        run_data = response.json()
        run_id = run_data['data']['id']
        print(f"‚è≥ Fetching subject property...")
        
        # Wait for subject property
        subject_property = None
        for i in range(60):
            time.sleep(2)
            status_response = requests.get(
                f'https://api.apify.com/v2/actor-runs/{run_id}',
                headers={'Authorization': f'Bearer {APIFY_TOKEN}'}
            )
            status_data = status_response.json()
            status = status_data['data']['status']
            
            if status == 'SUCCEEDED':
                dataset_id = status_data['data']['defaultDatasetId']
                results_response = requests.get(
                    f'https://api.apify.com/v2/datasets/{dataset_id}/items',
                    headers={'Authorization': f'Bearer {APIFY_TOKEN}'}
                )
                properties = results_response.json()
                
                if properties and len(properties) > 0:
                    prop = properties[0]
                    if prop.get('error'):
                        print(f"‚ùå Property not found: {prop['error']}")
                        return None
                    
                    # Parse address
                    full_address = prop.get('address', address)
                    address_parts = full_address.split(',')
                    city = address_parts[1].strip() if len(address_parts) > 1 else ''
                    state_zip = address_parts[2].strip() if len(address_parts) > 2 else ''
                    state = state_zip.split()[0] if state_zip else ''
                    zipcode = state_zip.split()[1] if len(state_zip.split()) > 1 else ''
                    
                    subject_property = {
                        'address': full_address,
                        'city': city,
                        'state': state,
                        'zipcode': zipcode,
                        'beds': prop.get('beds', 3),
                        'baths': prop.get('baths', 2),
                        'sqft': prop.get('area', 1800),
                        'year_built': prop.get('yearBuilt', 2000),
                        'lot_size': prop.get('lotSize', 0.25),
                        'latitude': prop.get('latLong', {}).get('latitude'),
                        'longitude': prop.get('latLong', {}).get('longitude'),
                        'zestimate': prop.get('zestimate', 0),
                        'rent_zestimate': prop.get('rentZestimate', 0),
                        'zpid': prop.get('zpid', ''),
                        'status': prop.get('statusText', 'Unknown'),
                        'image_url': prop.get('imgSrc', ''),
                        'zillow_url': f"https://www.zillow.com{prop.get('detailUrl', '')}" if prop.get('detailUrl') else ''
                    }
                    
                    print(f"‚úÖ Subject: {subject_property['beds']}bd/{subject_property['baths']}ba, {subject_property['sqft']}sqft")
                    print(f"üí∞ Zestimate: ${subject_property['zestimate']:,}")
                    print(f"üèòÔ∏è Rent Zestimate: ${subject_property['rent_zestimate']:,}/mo")
                    break
                    
            elif status == 'FAILED':
                print("‚ùå Subject property fetch failed")
                return None
        
        if not subject_property:
            print("‚è±Ô∏è  Timeout getting subject property")
            return None
        
        # STEP 2: Get comps using subject property data
        print(f"üîç Fetching comps for {subject_property['zipcode']}...")
        
        min_year = max(1900, subject_property['year_built'] - 10) if subject_property['year_built'] else 1900
        max_year = (subject_property['year_built'] + 10) if subject_property['year_built'] else 2025
        min_sqft = str(int(subject_property['sqft'] * 0.8))
        max_sqft = str(int(subject_property['sqft'] * 1.2))
        
        comps_input = {
            "location": subject_property['zipcode'],
            "operation": "sold",
            "sortBy": "newest",
            "minBeds": max(1, subject_property['beds'] - 1),
            "maxBeds": subject_property['beds'] + 1,
            "minBaths": max(1, subject_property['baths'] - 1),
            "homeTypes": ["houses"],
            "minYearBuilt": min_year,
            "maxYearBuilt": max_year,
            "minSize": min_sqft,
            "maxSize": max_sqft,
            "maxSoldDate": "6m",
            "maxItems": 30
        }
        
        # Start comps fetch
        comps_response = requests.post(
            'https://api.apify.com/v2/acts/igolaizola~zillow-scraper-ppe/runs',
            headers={'Authorization': f'Bearer {APIFY_TOKEN}'},
            json=comps_input,
            timeout=120
        )
        
        if comps_response.status_code != 201:
            print(f"‚ùå Comps fetch error: {comps_response.status_code}")
            # Return subject only, no comps
            return {
                'subject': subject_property,
                'comps': []
            }
        
        comps_run_data = comps_response.json()
        comps_run_id = comps_run_data['data']['id']
        
        # Wait for comps
        comps = []
        for i in range(60):
            time.sleep(2)
            comps_status = requests.get(
                f'https://api.apify.com/v2/actor-runs/{comps_run_id}',
                headers={'Authorization': f'Bearer {APIFY_TOKEN}'}
            )
            comps_status_data = comps_status.json()
            status = comps_status_data['data']['status']
            
            if status == 'SUCCEEDED':
                dataset_id = comps_status_data['data']['defaultDatasetId']
                comps_results = requests.get(
                    f'https://api.apify.com/v2/datasets/{dataset_id}/items',
                    headers={'Authorization': f'Bearer {APIFY_TOKEN}'}
                )
                raw_comps = comps_results.json()
                
                # Process comps
                for comp in raw_comps:
                    if (comp.get('bedrooms') and comp.get('bathrooms') and 
                        comp.get('livingArea') and comp.get('price')):
                        
                        # Calculate distance
                        distance = 999
                        if (subject_property.get('latitude') and subject_property.get('longitude') and
                            comp.get('latitude') and comp.get('longitude')):
                            distance = haversine_distance(
                                subject_property['latitude'], subject_property['longitude'],
                                comp['latitude'], comp['longitude']
                            )
                        
                        # Only include comps within 2 miles
                        if distance <= 2.0:
                            comp_data = {
                                'address': comp.get('address', {}).get('streetAddress', 'Unknown'),
                                'city': comp.get('address', {}).get('city', ''),
                                'state': comp.get('address', {}).get('state', ''),
                                'zipcode': comp.get('address', {}).get('zipcode', ''),
                                'price': comp['price']['value'],
                                'beds': comp['bedrooms'],
                                'baths': comp['bathrooms'],
                                'sqft': comp['livingArea'],
                                'year_built': comp.get('yearBuilt', 0),
                                'price_per_sqft': round(comp['price']['value'] / comp['livingArea'], 2),
                                'distance_miles': round(distance, 2),
                                'sold_date': comp.get('listing', {}).get('dateSold', 'Unknown'),
                                'days_on_market': comp.get('daysOnZillow', 0),
                                'zpid': comp.get('zpid', ''),
                                'image_url': comp.get('imgSrc', ''),
                                'zillow_url': f"https://www.zillow.com/homedetails/{comp.get('zpid', '')}_zpid/" if comp.get('zpid') else ''
                            }
                            comps.append(comp_data)
                
                # Sort by distance
                comps.sort(key=lambda x: x['distance_miles'])
                print(f"‚úÖ Found {len(comps)} comps within 2 miles")
                break
                
            elif status == 'FAILED':
                print("‚ùå Comps fetch failed")
                break
        
        return {
            'subject': subject_property,
            'comps': comps[:10]  # Return top 10 closest
        }
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        return None

def calculate_scenarios(property_data, avg_price_per_sqft, estimated_arv):
    """Calculate all investment scenarios"""
    purchase = property_data['purchasePrice']
    sqft = property_data['currentSqft']
    lot_acres = property_data.get('lotSize', 0.25)
    
    scenarios = []
    
    # Fix & Flip scenarios
    rehab_costs = {
        'light': sqft * 25,
        'medium': sqft * 45,
        'heavy': sqft * 75
    }
    
    for level, rehab in rehab_costs.items():
        holding_time = 4 if level == 'light' else 6 if level == 'medium' else 8
        hard_money_rate = 0.12
        hard_money_months = holding_time
        
        interest = (purchase * 0.8) * (hard_money_rate / 12) * hard_money_months
        closing_costs = estimated_arv * 0.06
        holding_costs = holding_time * 500
        
        total_investment = purchase + rehab + interest + closing_costs + holding_costs
        sale_proceeds = estimated_arv * 0.94
        profit = sale_proceeds - total_investment
        roi = (profit / total_investment * 100) if total_investment > 0 else 0
        
        scenarios.append({
            'name': f'Fix & Flip ({level.title()})',
            'total_investment': round(total_investment),
            'sale_proceeds': round(sale_proceeds),
            'profit': round(profit),
            'roi': round(roi, 1),
            'timeline_days': holding_time * 30,
            'details': {
                'purchase': purchase,
                'rehab': round(rehab),
                'interest': round(interest),
                'closing_costs': round(closing_costs),
                'holding': round(holding_costs),
                'arv': round(estimated_arv)
            }
        })
    
    # Wholesale
    assignment_fee = purchase * 0.06
    wholesale_profit = assignment_fee
    wholesale_roi = (wholesale_profit / 1000 * 100)
    
    scenarios.append({
        'name': 'Wholesale Assignment',
        'total_investment': 1000,
        'profit': round(wholesale_profit),
        'roi': round(wholesale_roi, 1),
        'timeline_days': 30,
        'details': {
            'contract_price': purchase,
            'assignment_fee': round(assignment_fee),
            'buyer_price': round(purchase + assignment_fee)
        }
    })
    
    scenarios.sort(key=lambda x: x['roi'], reverse=True)
    
    return scenarios

@app.route('/api/lookup-property', methods=['POST'])
def lookup_property():
    """Fetch subject property AND comps in ONE call"""
    try:
        data = request.json
        address = data.get('address', '')
        
        if not address:
            return jsonify({'error': 'Address required'}), 400
        
        result = fetch_property_and_comps(address)
        
        if result:
            return jsonify(result)
        else:
            return jsonify({'error': 'Property not found'}), 404
            
    except Exception as e:
        print(f"‚ùå Error in lookup: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@app.route('/api/analyze', methods=['POST'])
def analyze_property():
    """Main analysis endpoint"""
    try:
        data = request.json
        
        property_data = {
            'address': data['address'],
            'purchasePrice': float(data['purchasePrice']),
            'currentSqft': float(data['currentSqft']),
            'beds': int(data.get('beds', 3)),
            'baths': float(data.get('baths', 2)),
            'lotSize': float(data.get('lotSize', 0.25)),
            'zipcode': data.get('zipcode', ''),
            'yearBuilt': int(data.get('yearBuilt', 2000)),
            'latitude': data.get('latitude'),
            'longitude': data.get('longitude'),
            'zestimate': data.get('zestimate', 0),
            'rent_zestimate': data.get('rent_zestimate', 0)
        }
        
        # Get comps data from request (already fetched)
        comps = data.get('comps', [])
        
        print(f"\nüè† Analyzing: {property_data['address']}")
        print(f"üí∞ Zestimate: ${property_data['zestimate']:,}")
        print(f"üèòÔ∏è Rent Zestimate: ${property_data['rent_zestimate']:,}")
        
        # Calculate averages
        if comps:
            avg_price = sum(c['price'] for c in comps) / len(comps)
            avg_price_per_sqft = sum(c['price_per_sqft'] for c in comps) / len(comps)
        else:
            avg_price = property_data['zestimate']
            avg_price_per_sqft = property_data['zestimate'] / property_data['currentSqft'] if property_data['currentSqft'] > 0 else 150
        
        estimated_arv = avg_price_per_sqft * property_data['currentSqft']
        
        # Calculate scenarios
        scenarios = calculate_scenarios(property_data, avg_price_per_sqft, estimated_arv)
        
        result = {
            'address': property_data['address'],
            'zestimate': property_data['zestimate'],
            'rent_zestimate': property_data['rent_zestimate'],
            'comps': {
                'total_found': len(comps),
                'average_price': round(avg_price) if comps else 0,
                'average_price_per_sqft': round(avg_price_per_sqft, 2),
                'estimated_value': round(estimated_arv),
                'properties': comps[:5]
            },
            'scenarios': scenarios,
            'best_scenario': scenarios[0] if scenarios else None
        }
        
        return jsonify(result)
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@app.route('/api/report/pdf', methods=['POST'])
def create_pdf_report():
    """Generate PDF report"""
    try:
        data = request.json
        filename = generate_pdf_report(data)
        return send_file(filename, as_attachment=True)
    except Exception as e:
        print(f"‚ùå PDF Error: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@app.route('/api/report/excel', methods=['POST'])
def create_excel_report():
    """Generate Excel report"""
    try:
        data = request.json
        filename = generate_excel_report(data)
        return send_file(filename, as_attachment=True)
    except Exception as e:
        print(f"‚ùå Excel Error: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@app.route('/')
def index():
    return send_file('index.html')

@app.route('/complete_real_estate_analyzer.jsx')
def jsx_file():
    return send_file('complete_real_estate_analyzer.jsx')

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'apify_configured': bool(APIFY_TOKEN)
    })

if __name__ == '__main__':
    os.makedirs('reports', exist_ok=True)
    print("üöÄ Real Estate Analyzer API Starting...")
    print(f"üìä Apify Token: {'‚úÖ Configured' if APIFY_TOKEN else '‚ö†Ô∏è  Not Set (demo mode)'}")
    print("=" * 60)
    app.run(debug=True, port=5000)
